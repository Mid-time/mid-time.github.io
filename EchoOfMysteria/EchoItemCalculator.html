<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç¥ç§˜å›å“ç‰©å“è®¡ç®—å™¨</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ğŸŒŒ</text></svg>">
    <style>
        /* æ ·å¼ä¿æŒä¸å˜ï¼Œä¸ä¹‹å‰ç›¸åŒ */
        :root {
            --primary-color: #2c3e50;
            --secondary-color: #8e44ad;
            --accent-color: #e74c3c;
            --light-color: #ecf0f1;
            --dark-color: #34495e;
            --success-color: #2ecc71;
            --warning-color: #f39c12;
            --background-color: #f5f7fa;
            --card-color: #ffffff;
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: var(--background-color);
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: var(--card-color);
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }
        
        header {
            background: var(--primary-color);
            color: white;
            padding: 20px;
            text-align: center;
            position: relative;
        }
        
        h1 {
            margin-bottom: 10px;
        }
        
        .description {
            font-size: 1.1rem;
            opacity: 0.9;
        }
        
        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            padding: 20px;
        }
        
        @media (max-width: 768px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }
        
        .section {
            background: var(--card-color);
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
        }
        
        .section-title {
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid var(--secondary-color);
            color: var(--primary-color);
        }
        
        .calculator {
            grid-column: 1 / -1;
            background: var(--light-color);
            border-radius: 8px;
            padding: 15px;
        }
        
        .calculator-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 10px;
        }
        
        .calculator-item {
            background: var(--card-color);
            border-radius: 6px;
            padding: 10px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            display: grid;
            grid-template-rows: auto auto;
            gap: 8px;
        }
        
        .calculator-item-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
        }
        
        .calculator-item-name {
            font-weight: bold;
            font-size: 0.9rem;
            flex: 1;
        }
        
        .calculator-item-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 3px;
            margin-top: 3px;
        }
        
        .calculator-tag {
            background: var(--secondary-color);
            color: white;
            padding: 1px 5px;
            border-radius: 8px;
            font-size: 0.7rem;
        }
        
        .calculator-item-details {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.8rem;
            color: var(--dark-color);
        }
        
        .calculator-item-description {
            font-size: 0.8rem;
            color: #666;
            overflow: hidden;
            text-overflow: ellipsis;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            line-height: 1.2;
        }
        
        .calculator-item-controls {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .quantity-input {
            width: 50px;
            padding: 3px;
            text-align: center;
            border: 1px solid #ddd;
            border-radius: 3px;
        }
        
        .calculator-item-cost {
            font-weight: bold;
        }
        
        .filter-group {
            margin-bottom: 15px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: var(--dark-color);
        }
        
        input, textarea, select {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: inherit;
            font-size: 1rem;
        }
        
        .tag-filter {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-top: 5px;
        }
        
        .tag-option {
            background: #eee;
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: background 0.3s;
        }
        
        .tag-option.selected {
            background: var(--secondary-color);
            color: white;
        }
        
        .tag-option.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .cost-range {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .cost-range input {
            width: 80px;
        }
        
        .sort-group {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .sort-group select {
            flex: 1;
        }
        
        button {
            background: var(--secondary-color);
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: background 0.3s;
        }
        
        button:hover {
            background: #7d3c98;
        }
        
        .btn-danger {
            background: var(--accent-color);
        }
        
        .btn-danger:hover {
            background: #c0392b;
        }
        
        .btn-success {
            background: var(--success-color);
        }
        
        .btn-success:hover {
            background: #27ae60;
        }
        
        .btn-warning {
            background: var(--warning-color);
        }
        
        .btn-warning:hover {
            background: #e67e22;
        }
        
        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }
        
        .item-list {
            max-height: 600px;
            overflow-y: auto;
            margin-bottom: 15px;
        }
        
        .item-card {
            background: var(--light-color);
            border-radius: 6px;
            padding: 15px;
            margin-bottom: 15px;
            border-left: 4px solid var(--secondary-color);
        }
        
        .item-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 10px;
        }
        
        .item-name {
            font-weight: bold;
            font-size: 1.1rem;
            color: var(--primary-color);
        }
        
        .item-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin: 5px 0;
        }
        
        .tag {
            background: var(--secondary-color);
            color: white;
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 0.8rem;
        }
        
        .item-description {
            margin: 10px 0;
            line-height: 1.5;
            font-size: 0.9rem;
        }
        
        .item-footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 10px;
            font-size: 0.9rem;
            color: var(--dark-color);
        }
        
        .empty-state {
            text-align: center;
            padding: 30px;
            color: #7f8c8d;
        }
        
        .status-message {
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 15px;
            text-align: center;
        }
        
        .status-success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        
        .status-error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        
        .help-text {
            font-size: 0.8rem;
            color: #7f8c8d;
            margin-top: 5px;
        }
        
        .pagination {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #ddd;
        }
        
        .pagination-controls {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .pagination button {
            padding: 5px 10px;
        }
        
        .pagination-info {
            font-size: 0.9rem;
            color: var(--dark-color);
        }
        
        .items-per-page {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .items-per-page input {
            width: 60px;
        }
        
        .total-cost {
            text-align: right;
            font-weight: bold;
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #ddd;
        }
        
        .weight-status {
            display: flex;
            justify-content: space-between;
            margin-top: 10px;
            padding: 10px;
            border-radius: 4px;
            background: #f8f9fa;
        }
        
        .weight-status.light {
            background: #d4edda;
            color: #155724;
        }
        
        .weight-status.normal {
            background: #d1ecf1;
            color: #0c5460;
        }
        
        .weight-status.heavy {
            background: #fff3cd;
            color: #856404;
        }
        
        .weight-status.overloaded {
            background: #f8d7da;
            color: #721c24;
        }
        
        .preset-section {
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid #ddd;
        }
        
        .preset-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 10px;
        }
        
        .preset-btn {
            background: var(--primary-color);
        }
        
        .preset-btn:hover {
            background: #1a252f;
        }
        
        .currency-display {
            font-size: 1.1rem;
            font-weight: bold;
            color: var(--primary-color);
        }
        
        .item-id {
            font-family: monospace;
            background: #f0f0f0;
            padding: 2px 5px;
            border-radius: 3px;
            font-size: 0.8rem;
        }
        
        /* æ–°å¢æ ·å¼ */
        .status-loading {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }
        
        .status-warning {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }
        
        .status-healthy {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        
        .recovery-panel {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }
        
        .recovery-actions {
            display: flex;
            gap: 10px;
            margin-top: 10px;
            flex-wrap: wrap;
        }
        
        .health-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 5px;
        }
        
        .health-healthy {
            background-color: #28a745;
        }
        
        .health-warning {
            background-color: #ffc107;
        }
        
        .health-error {
            background-color: #dc3545;
        }
        
        .data-source-info {
            font-size: 0.8rem;
            color: #6c757d;
            margin-top: 5px;
        }
        
        .data-health-panel {
            background: #f8f9fa;
            border-radius: 6px;
            padding: 10px;
            margin: 10px 0;
            font-size: 0.9rem;
        }
        
        .data-health-item {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
        }
        
        .health-status {
            display: flex;
            align-items: center;
        }
        
        .hierarchical-tags {
            margin-bottom: 15px;
        }
        
        .type-selector {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }
        
        .type-selector select {
            flex: 1;
        }
        
        .filter-rule-selector {
            display: flex;
            gap: 15px;
            margin-top: 10px;
        }
        
        .filter-rule-selector label {
            display: flex;
            align-items: center;
            gap: 5px;
            margin-bottom: 0;
            cursor: pointer;
        }
        
        .filter-rule-selector input {
            width: auto;
        }
        
        .active-filters {
            background: #f8f9fa;
            border-radius: 6px;
            padding: 10px;
            margin: 10px 0;
        }
        
        .active-filter-tag {
            display: inline-flex;
            align-items: center;
            background: var(--secondary-color);
            color: white;
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 0.8rem;
            margin: 2px 5px 2px 0;
        }
        
        .active-filter-tag .remove {
            margin-left: 5px;
            cursor: pointer;
            font-weight: bold;
        }
        
        .filter-summary {
            font-size: 0.9rem;
            color: #6c757d;
            margin-bottom: 5px;
        }
        
        .filter-category {
            margin-bottom: 15px;
            border: 1px solid #e9ecef;
            border-radius: 6px;
            padding: 10px;
        }
        
        .filter-category-title {
            font-weight: bold;
            margin-bottom: 8px;
            color: var(--primary-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .filter-category-content {
            max-height: 200px;
            overflow-y: auto;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>ç¥ç§˜å›å“ç‰©å“è®¡ç®—å™¨</h1>
            <p class="description">åŸºäºã€Šç¥ç§˜å›å“ã€‹è§„åˆ™ä¹¦v0.8.1çš„ç‰©å“ç®¡ç†ä¸è´Ÿé‡è®¡ç®—å·¥å…·</p>
            <div id="data-status" class="status-message"></div>
        </header>
        
        <!-- æ•°æ®æ¢å¤é¢æ¿ -->
        <div id="recovery-container"></div>
        
        <!-- ç¬¬ä¸€éƒ¨åˆ†ï¼šè®¡ç®—å™¨ -->
        <div class="calculator">
            <h2 class="section-title">å½“å‰è®¡ç®—ç‰©å“</h2>
            <div id="calculator-items" class="calculator-grid">
                <div class="empty-state">è®¡ç®—å™¨ä¸ºç©ºï¼Œè¯·ä»ç­›é€‰ç»“æœä¸­æ·»åŠ ç‰©å“</div>
            </div>
            <div id="total-cost" class="total-cost"></div>
            <div id="weight-status" class="weight-status">
                <div>æ€»é‡é‡: <span id="total-weight">0</span></div>
                <div>è´Ÿé‡çŠ¶æ€: <span id="carry-status">è½»å¿«</span></div>
            </div>
            
            <div class="preset-section">
                <h3>é¢„è®¾è£…å¤‡åŒ…</h3>
                <div class="preset-buttons">
                    <button class="preset-btn" data-preset="æˆ˜å£«">æˆ˜å£«è£…å¤‡åŒ…</button>
                    <button class="preset-btn" data-preset="æ³•å¸ˆ">æ³•å¸ˆè£…å¤‡åŒ…</button>
                    <button class="preset-btn" data-preset="æ¸¸è¡è€…">æ¸¸è¡è€…è£…å¤‡åŒ…</button>
                    <button class="btn-danger" id="clear-calculator">æ¸…ç©ºè®¡ç®—å™¨</button>
                </div>
            </div>
        </div>
        
        <div class="main-content">
            <!-- ç¬¬äºŒéƒ¨åˆ†ï¼šç­›é€‰å™¨ -->
            <div class="section">
                <h2 class="section-title">ç‰©å“ç­›é€‰</h2>
                
                <div class="filter-group">
                    <label>è§’è‰²å±æ€§</label>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                        <div>
                            <label for="character-strength">åŠ›é‡</label>
                            <input type="number" id="character-strength" min="0" max="12" value="5">
                        </div>
                        <div>
                            <label for="character-endurance">è€æ€§</label>
                            <input type="number" id="character-endurance" min="0" max="12" value="5">
                        </div>
                    </div>
                    <div class="help-text">æ ¹æ®è§„åˆ™ä¹¦v0.8.1ï¼Œå±æ€§åŒºé—´ä¸º0-12</div>
                </div>
                
                <!-- æ•°æ®å¥åº·åº¦é¢æ¿ -->
                <div id="data-health-panel" class="data-health-panel" style="display: none;">
                    <h4>æ•°æ®å¥åº·çŠ¶æ€</h4>
                    <div class="data-health-item">
                        <span>ç‰©å“æ•°æ®:</span>
                        <div class="health-status">
                            <span id="items-health-indicator" class="health-indicator"></span>
                            <span id="items-health-text">åŠ è½½ä¸­...</span>
                        </div>
                    </div>
                    <div class="data-health-item">
                        <span>ç±»å‹æ˜ å°„:</span>
                        <div class="health-status">
                            <span id="mapping-health-indicator" class="health-indicator"></span>
                            <span id="mapping-health-text">åŠ è½½ä¸­...</span>
                        </div>
                    </div>
                    <div class="data-health-item">
                        <span>é¢„è®¾è£…å¤‡åŒ…:</span>
                        <div class="health-status">
                            <span id="presets-health-indicator" class="health-indicator"></span>
                            <span id="presets-health-text">åŠ è½½ä¸­...</span>
                        </div>
                    </div>
                </div>
                
                <!-- åˆ†å±‚æ ‡ç­¾ç­›é€‰ -->
                <div class="filter-group">
                    <label>ç±»å‹ç­›é€‰</label>
                    <div class="hierarchical-tags">
                        <div class="type-selector">
                            <select id="main-type-filter">
                                <option value="">æ‰€æœ‰ä¸»ç±»å‹</option>
                            </select>
                            <select id="sub-type-filter" style="display: none;">
                                <option value="">æ‰€æœ‰å­ç±»å‹</option>
                            </select>
                        </div>
                    </div>
                </div>
                
                <!-- å½“å‰æ´»åŠ¨ç­›é€‰ -->
                <div id="active-filters" class="active-filters" style="display: none;">
                    <div class="filter-summary">å½“å‰ç­›é€‰æ¡ä»¶:</div>
                    <div id="active-filter-tags"></div>
                </div>
                
                <div id="status-message"></div>
                
                <!-- æ ‡ç­¾ç­›é€‰ -->
                <div id="tag-filter-container">
                    <!-- åŠ¨æ€ç”Ÿæˆçš„æ ‡ç­¾ç­›é€‰å™¨ -->
                </div>
                
                <div class="filter-group">
                    <label>åç§°æœç´¢</label>
                    <input type="text" id="name-filter" placeholder="è¾“å…¥ç‰©å“åç§°...">
                </div>
                
                <div class="filter-group">
                    <label>ä»·æ ¼èŒƒå›´ï¼ˆé“œå¸ï¼‰</label>
                    <div class="cost-range">
                        <input type="number" id="min-cost" placeholder="æœ€ä½" min="0">
                        <span>è‡³</span>
                        <input type="number" id="max-cost" placeholder="æœ€é«˜" min="0">
                    </div>
                </div>
                
                <div class="filter-group">
                    <label>æ’åºæ–¹å¼</label>
                    <div class="sort-group">
                        <select id="sort-by">
                            <option value="name-asc">åç§° A-Z</option>
                            <option value="name-desc">åç§° Z-A</option>
                            <option value="cost-asc">ä»·æ ¼ ä½åˆ°é«˜</option>
                            <option value="cost-desc">ä»·æ ¼ é«˜åˆ°ä½</option>
                            <option value="weight-asc">é‡é‡ è½»åˆ°é‡</option>
                            <option value="weight-desc">é‡é‡ é‡åˆ°è½»</option>
                        </select>
                    </div>
                </div>
                
                <div class="button-group">
                    <button type="button" id="clear-filter">æ¸…é™¤ç­›é€‰</button>
                </div>
            </div>
            
            <!-- ç¬¬ä¸‰éƒ¨åˆ†ï¼šç­›é€‰ç»“æœ -->
            <div class="section">
                <h2 class="section-title">ç­›é€‰ç»“æœ</h2>
                <div id="item-list" class="item-list">
                    <div class="empty-state">æ­£åœ¨åŠ è½½ç‰©å“æ•°æ®...</div>
                </div>
                
                <!-- åˆ†é¡µæ§ä»¶ -->
                <div id="pagination" class="pagination" style="display: none;">
                    <div class="pagination-controls">
                        <button id="prev-page">ä¸Šä¸€é¡µ</button>
                        <span id="page-info" class="pagination-info">ç¬¬ 1 é¡µï¼Œå…± 1 é¡µ</span>
                        <button id="next-page">ä¸‹ä¸€é¡µ</button>
                    </div>
                    <div class="items-per-page">
                        <label for="items-per-page">æ¯é¡µæ˜¾ç¤º:</label>
                        <input type="number" id="items-per-page" min="5" max="100" value="20">
                        <span>ä¸ª</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ================================
        // æ¨¡å—åŒ–è®¾è®¡ï¼šæ•°æ®ç®¡ç†å™¨
        // ================================
        class EchoDataManager {
            constructor() {
                this.dataSources = {
                    items: [
                        { type: 'local', url: './EchoItemCalculator/Item.csv', priority: 3 },
                        { type: 'localStorage', key: 'echo_items_cache', priority: 2 },
                        { type: 'builtin', data: this.getBuiltinItems(), priority: 1 }
                    ],
                    mapping: [
                        { type: 'local', url: './EchoItemCalculator/ItemType.csv', priority: 3 },
                        { type: 'localStorage', key: 'echo_mapping_cache', priority: 2 },
                        { type: 'builtin', data: this.getBuiltinTypeMapping(), priority: 1 }
                    ],
                    presets: [
                        { type: 'local', url: './EchoItemCalculator/ItemBuildinPreset.csv', priority: 3 },
                        { type: 'localStorage', key: 'echo_presets_cache', priority: 2 },
                        { type: 'builtin', data: this.getBuiltinPresets(), priority: 1 }
                    ]
                };
                
                this.sourceInfo = {
                    items: { source: 'æœªçŸ¥', count: 0, version: null },
                    mapping: { source: 'æœªçŸ¥', count: 0, version: null },
                    presets: { source: 'æœªçŸ¥', count: 0, version: null }
                };
                
                this.versionInfo = {
                    items: null,
                    mapping: null,
                    presets: null
                };
            }
            
            // è·å–æ•°æ®æ¥æºä¿¡æ¯
            getSourceInfo() {
                return this.sourceInfo;
            }
            
            // è·å–ç‰ˆæœ¬ä¿¡æ¯
            getVersionInfo() {
                return this.versionInfo;
            }
            
            // åŠ è½½ç‰©å“æ•°æ®
            async loadItems() {
                for (const source of this.dataSources.items.sort((a, b) => b.priority - a.priority)) {
                    try {
                        const data = await this.loadFromSource(source, 'items');
                        if (data && data.length > 0) {
                            this.sourceInfo.items = { 
                                source: source.type, 
                                count: data.length,
                                version: this.versionInfo.items
                            };
                            return data;
                        }
                    } catch (error) {
                        console.warn(`ä» ${source.type} åŠ è½½ç‰©å“æ•°æ®å¤±è´¥:`, error.message);
                    }
                }
                this.sourceInfo.items = { source: 'error', count: 0, version: null };
                throw new Error('æ‰€æœ‰ç‰©å“æ•°æ®æºå‡åŠ è½½å¤±è´¥');
            }
            
            // åŠ è½½ç±»å‹æ˜ å°„
            async loadTypeMapping() {
                for (const source of this.dataSources.mapping.sort((a, b) => b.priority - a.priority)) {
                    try {
                        const data = await this.loadFromSource(source, 'mapping');
                        if (data && data.size > 0) {
                            this.sourceInfo.mapping = { 
                                source: source.type, 
                                count: data.size,
                                version: this.versionInfo.mapping
                            };
                            return data;
                        }
                    } catch (error) {
                        console.warn(`ä» ${source.type} åŠ è½½ç±»å‹æ˜ å°„å¤±è´¥:`, error.message);
                    }
                }
                this.sourceInfo.mapping = { source: 'error', count: 0, version: null };
                throw new Error('æ‰€æœ‰ç±»å‹æ˜ å°„æ•°æ®æºå‡åŠ è½½å¤±è´¥');
            }
            
            // åŠ è½½é¢„è®¾è£…å¤‡åŒ…
            async loadPresets() {
                for (const source of this.dataSources.presets.sort((a, b) => b.priority - a.priority)) {
                    try {
                        const data = await this.loadFromSource(source, 'presets');
                        if (data && data.size > 0) {
                            this.sourceInfo.presets = { 
                                source: source.type, 
                                count: data.size,
                                version: this.versionInfo.presets
                            };
                            return data;
                        }
                    } catch (error) {
                        console.warn(`ä» ${source.type} åŠ è½½é¢„è®¾è£…å¤‡åŒ…å¤±è´¥:`, error.message);
                    }
                }
                this.sourceInfo.presets = { source: 'error', count: 0, version: null };
                throw new Error('æ‰€æœ‰é¢„è®¾è£…å¤‡åŒ…æ•°æ®æºå‡åŠ è½½å¤±è´¥');
            }
            
            // ä»æŒ‡å®šæºåŠ è½½æ•°æ®
            async loadFromSource(source, dataType) {
                switch (source.type) {
                    case 'local':
                        return await this.loadRemoteData(source.url, dataType);
                    case 'localStorage':
                        return this.loadLocalStorageData(source.key, dataType);
                    case 'builtin':
                        return this.processBuiltinData(source.data, dataType);
                    default:
                        throw new Error(`æœªçŸ¥æ•°æ®æºç±»å‹: ${source.type}`);
                }
            }
            
            // åŠ è½½è¿œç¨‹æ•°æ®
            async loadRemoteData(url, dataType) {
                try {
                    const response = await fetch(url);
                    if (!response.ok) {
                        throw new Error(`HTTPé”™è¯¯! çŠ¶æ€: ${response.status}`);
                    }
                    
                    const csvText = await response.text();
                    const data = this.parseCSVData(csvText, dataType);
                    
                    // ç¼“å­˜åˆ°localStorage
                    this.cacheData(url, data, dataType);
                    
                    return data;
                } catch (error) {
                    console.warn(`åŠ è½½è¿œç¨‹æ•°æ®å¤±è´¥: ${url}`, error);
                    return null;
                }
            }
            
            // åŠ è½½æœ¬åœ°å­˜å‚¨æ•°æ®
            loadLocalStorageData(key, dataType) {
                try {
                    const cached = localStorage.getItem(key);
                    if (!cached) return null;
                    
                    const parsed = JSON.parse(cached);
                    return this.processCachedData(parsed, dataType);
                } catch (error) {
                    console.warn(`è§£æç¼“å­˜æ•°æ®å¤±è´¥:`, error);
                    return null;
                }
            }
            
            // å¤„ç†å†…ç½®æ•°æ®
            processBuiltinData(data, dataType) {
                switch (dataType) {
                    case 'items':
                        return this.parseCSVData(data, 'items');
                    case 'mapping':
                        return this.parseCSVData(data, 'mapping');
                    case 'presets':
                        return this.parseCSVData(data, 'presets');
                    default:
                        throw new Error(`æœªçŸ¥æ•°æ®ç±»å‹: ${dataType}`);
                }
            }
            
            // ç¼“å­˜æ•°æ®
            cacheData(key, data, dataType) {
                try {
                    const cacheKey = this.getCacheKey(key, dataType);
                    localStorage.setItem(cacheKey, JSON.stringify({
                        data: data,
                        timestamp: Date.now(),
                        dataType: dataType,
                        version: this.versionInfo[dataType]
                    }));
                } catch (error) {
                    console.warn('ç¼“å­˜æ•°æ®å¤±è´¥:', error);
                }
            }
            
            // è·å–ç¼“å­˜é”®
            getCacheKey(url, dataType) {
                return `echo_${dataType}_cache`;
            }
            
            // å¤„ç†ç¼“å­˜æ•°æ®
            processCachedData(cached, dataType) {
                // æ£€æŸ¥ç¼“å­˜æ˜¯å¦è¿‡æœŸ (24å°æ—¶) æˆ–ç‰ˆæœ¬ä¸åŒ¹é…
                const isExpired = Date.now() - cached.timestamp > 24 * 60 * 60 * 1000;
                const versionMismatch = cached.version !== this.versionInfo[dataType];
                
                if (isExpired || versionMismatch) {
                    return null;
                }
                
                return cached.data;
            }
            
            // è§£æCSVæ•°æ® - æ”¯æŒæ—¥æœŸæ ¡éªŒç 
            parseCSVData(csvText, dataType) {
                if (!csvText || csvText.trim() === '') {
                    throw new Error('CSVå†…å®¹ä¸ºç©º');
                }
                
                const lines = csvText.trim().split('\n');
                
                // æ£€æµ‹ç¬¬ä¸€è¡Œæ˜¯å¦ä¸ºæ—¥æœŸæ ¡éªŒç ï¼ˆ8ä½æ•°å­—ï¼‰
                let startLine = 0;
                const firstLine = lines[0].trim();
                
                if (/^\d{8}$/.test(firstLine)) {
                    console.log(`æ£€æµ‹åˆ°æ—¥æœŸæ ¡éªŒç : ${firstLine}`);
                    this.versionInfo[dataType] = firstLine;
                    startLine = 1; // è·³è¿‡ç¬¬ä¸€è¡Œ
                }
                
                // å¦‚æœè·³è¿‡äº†æ—¥æœŸè¡Œï¼Œç¡®ä¿è¿˜æœ‰è¶³å¤Ÿçš„è¡Œ
                if (startLine >= lines.length) {
                    throw new Error('CSVæ–‡ä»¶å†…å®¹ä¸è¶³');
                }
                
                const headers = lines[startLine].split(',').map(header => header.trim());
                
                // æ ¹æ®æ£€æµ‹ç»“æœè°ƒæ•´æ•°æ®èµ·å§‹è¡Œ
                const dataStartLine = startLine + 1;
                
                switch (dataType) {
                    case 'items':
                        return this.parseItemsCSV(lines, headers, dataStartLine);
                    case 'mapping':
                        return this.parseMappingCSV(lines, headers, dataStartLine);
                    case 'presets':
                        return this.parsePresetsCSV(lines, headers, dataStartLine);
                    default:
                        throw new Error(`æœªçŸ¥æ•°æ®ç±»å‹: ${dataType}`);
                }
            }
            
            // è§£æç‰©å“CSV - æ”¯æŒè‡ªå®šä¹‰èµ·å§‹è¡Œ
            parseItemsCSV(lines, headers, startLine = 1) {
                const items = [];
                
                for (let i = startLine; i < lines.length; i++) {
                    if (lines[i].trim() === '') continue;
                    
                    const values = this.parseCSVLine(lines[i]);
                    const item = {};
                    
                    headers.forEach((header, index) => {
                        let value = values[index] || '';
                        
                        // å¤„ç†ä¸åŒçš„æ•°æ®ç±»å‹
                        if (header === 'tags') {
                            value = value.split(';').map(tag => tag.trim()).filter(tag => tag !== '');
                        } else if (header === 'cost' || header === 'weight') {
                            value = parseFloat(value) || 0;
                        } else if (header === 'rarity' || header === 'material' || header === 'skill') {
                            // æ–°å¢å­—æ®µï¼šç¨€æœ‰åº¦ã€æè´¨ã€æŠ€èƒ½éœ€æ±‚
                            value = value.trim();
                        } else if (header === 'id') {
                            // ç¡®ä¿IDæ˜¯å­—ç¬¦ä¸²
                            value = value.toString().trim();
                        } else {
                            value = value.trim();
                        }
                        
                        item[header] = value;
                    });
                    
                    // ç¡®ä¿æœ‰idå­—æ®µ
                    if (!item.id) {
                        item.id = `item_${i}`;
                    }
                    
                    items.push(item);
                }
                
                return items;
            }
            
            // è§£æç±»å‹æ˜ å°„CSV - æ”¯æŒè‡ªå®šä¹‰èµ·å§‹è¡Œ
            parseMappingCSV(lines, headers, startLine = 1) {
                const mapping = new Map();
                
                // æ–°çš„CSVæ ¼å¼ï¼štype_code,main_type,01,02,03,04,05,06,07,08,etc...
                const subTypeCodes = headers.slice(2);
                
                for (let i = startLine; i < lines.length; i++) {
                    if (lines[i].trim() === '') continue;
                    
                    const values = this.parseCSVLine(lines[i]);
                    if (values.length < 2) continue;
                    
                    const typeCode = values[0].trim();
                    const mainType = values[1].trim();
                    
                    // æ„å»ºå­ç±»å‹æ˜ å°„
                    const subTypes = new Map();
                    subTypeCodes.forEach((code, index) => {
                        const subTypeName = values[index + 2] ? values[index + 2].trim() : null;
                        if (subTypeName && subTypeName !== '') {
                            subTypes.set(code, subTypeName);
                        }
                    });
                    
                    mapping.set(typeCode, {
                        mainType: mainType,
                        subTypes: subTypes
                    });
                }
                
                return mapping;
            }
            
            // è§£æé¢„è®¾è£…å¤‡åŒ…CSV - æ–°æ ¼å¼ï¼šname,01,02,03,04
            parsePresetsCSV(lines, headers, startLine = 1) {
                const presets = new Map();
                
                for (let i = startLine; i < lines.length; i++) {
                    if (lines[i].trim() === '') continue;
                    
                    const values = this.parseCSVLine(lines[i]);
                    if (values.length < 1) continue;
                    
                    const name = values[0].trim();
                    if (!name) continue;
                    
                    // æ–°çš„é¢„è®¾æ ¼å¼ï¼šä»ç¬¬äºŒåˆ—å¼€å§‹æ˜¯è£…å¤‡æ§½ä½
                    const items = [];
                    for (let j = 1; j < values.length; j++) {
                        const slotValue = values[j].trim();
                        if (slotValue && slotValue !== '') {
                            // æ ¼å¼ï¼š'ç‰©å“å,æ•°é‡' æˆ– 'ç‰©å“ID,æ•°é‡' æˆ– ç›´æ¥æ˜¯ç‰©å“å
                            let itemName = slotValue;
                            let quantity = 1;
                            
                            // å°è¯•è§£æå¸¦æ•°é‡çš„æ ¼å¼
                            const commaMatch = slotValue.match(/'?([^,]+),(\d+)'?/);
                            if (commaMatch) {
                                itemName = commaMatch[1].trim();
                                quantity = parseInt(commaMatch[2]) || 1;
                            }
                            
                            items.push({
                                name: itemName,
                                quantity: quantity
                            });
                        }
                    }
                    
                    presets.set(name, {
                        name: name,
                        items: items
                    });
                }
                
                return presets;
            }
            
            // è§£æCSVè¡Œï¼Œå¤„ç†å¼•å·å†…çš„é€—å·
            parseCSVLine(line) {
                const result = [];
                let current = '';
                let inQuotes = false;
                
                for (let i = 0; i < line.length; i++) {
                    const char = line[i];
                    
                    if (char === '"') {
                        inQuotes = !inQuotes;
                    } else if (char === ',' && !inQuotes) {
                        result.push(current);
                        current = '';
                    } else {
                        current += char;
                    }
                }
                
                result.push(current);
                return result.map(field => field.trim());
            }
            
            // å¼ºåˆ¶åˆ·æ–°æ•°æ®
            async forceRefresh() {
                // æ¸…é™¤æ‰€æœ‰ç¼“å­˜
                Object.values(this.dataSources).forEach(sources => {
                    sources.forEach(source => {
                        if (source.type === 'localStorage') {
                            localStorage.removeItem(source.key);
                        }
                    });
                });
                
                // é‡æ–°åŠ è½½æ•°æ®
                window.location.reload();
            }
            
            // ä½¿ç”¨å¤‡ç”¨æ•°æ®
            useFallbackData() {
                // æ¸…é™¤æ‰€æœ‰ç¼“å­˜
                Object.values(this.dataSources).forEach(sources => {
                    sources.forEach(source => {
                        if (source.type === 'localStorage') {
                            localStorage.removeItem(source.key);
                        }
                    });
                });
                
                // è®¾ç½®åªä½¿ç”¨å†…ç½®æ•°æ®
                this.dataSources.items = this.dataSources.items.filter(s => s.type === 'builtin');
                this.dataSources.mapping = this.dataSources.mapping.filter(s => s.type === 'builtin');
                this.dataSources.presets = this.dataSources.presets.filter(s => s.type === 'builtin');
                
                // é‡æ–°åŠ è½½æ•°æ®
                window.location.reload();
            }
            
            // å†…ç½®ç‰©å“æ•°æ®
            getBuiltinItems() {
                return `20240520
id,name,tags,description,cost,weight,rarity,material,skill
0101001,é“ç›¾,"æ­¦å™¨;ç›¾ç‰Œ;é‡‘å±","æ‰“å‡»2-4ä¼¤å®³ï¼Œ20%æ¦‚ç‡æ–½åŠ æ··ä¹±I 1-3ï¼Œæ‹›æ¶3-8ä¼¤å®³",10000,10,æ™®é€š,é‡‘å±,åŠ›é‡5
0102001,é“å‰‘,"æ­¦å™¨;å‰‘;é‡‘å±","é€ æˆæµè¡€2-6ä¼¤å®³ï¼Œ15%æ¦‚ç‡æ–½åŠ æµè¡€I 1-3",9000,20,æ™®é€š,é‡‘å±,åŠ›é‡5
0201001,çš®é©å¤§è¡£,"æŠ¤ç”²;çš®é©","æä¾›ç‰©ç†æŠ¤ç”²0.3å’Œé­”æ³•æŠ¤ç”²0.3",4500,5,æ™®é€š,çš®é©,æ— 
0301001,æ²»ç–—è¯æ°´,"æ¶ˆè€—å“;æ²»ç–—","é¥®ç”¨åæ¢å¤6ç‚¹ç”Ÿå‘½å€¼ï¼Œä½†ä¼šæŠ‘åˆ¶HPæ¢å¤",500,1,æ™®é€š,ç»ç’ƒ,æ— 
0105001,æœ¨å¼“,"æ­¦å™¨;è¿œç¨‹;æœ¨è´¨","ç®­çŸ¢ä¼¤å®³2-6ï¼Œè“„åŠ›æ—¶ä¼¤å®³4-6ï¼Œå‘½ä¸­ç‡+5%",6000,6,æ™®é€š,æœ¨è´¨,æ•æ·4
0107001,è“ç‰æ³•æ–,"æ­¦å™¨;é­”æ³•;æ³•æ–","è•´å«å†°é­”æ³•çš„æ³•æ–ï¼Œé€ æˆå†°å†»1-8ä¼¤å®³ï¼Œ20%æ¦‚ç‡æ–½åŠ å†°å†»I 1",12500,12,ç¨€æœ‰,ç‰çŸ³,æ™ºåŠ›6
0202001,æ—…äººé£è¡£,"æŠ¤ç”²;å¸ƒç”²","é€‚åˆæ—…è¡Œçš„é£è¡£ï¼Œæä¾›CP+5å’Œ+10%é—ªé¿ç‡",9000,3,æ™®é€š,å¸ƒæ–™,æ— 
0501001,å¸ƒåŒ…,"å®¹å™¨;èƒŒåŒ…","å¢åŠ 4ç‚¹è´Ÿé‡å®¹é‡",2500,1,æ™®é€š,å¸ƒæ–™,æ— 
0401001,ç«æŠŠ,"å·¥å…·;ç…§æ˜","æä¾›å…‰èŠ’+1",200,1,æ™®é€š,æœ¨è´¨,æ— 
0203001,å®‰å…¨å¸½,"æŠ¤ç”²;å¤´ç›”","ä¿æŠ¤å¤´éƒ¨ï¼Œæä¾›ç‰©ç†æŠ¤ç”²1",4000,2,æ™®é€š,é‡‘å±,æ— `;
            }
            
            // å†…ç½®ç±»å‹æ˜ å°„ - ä¿®æ”¹ä¸ºæ–°çš„æ ¼å¼
            getBuiltinTypeMapping() {
                return `20240520
type_code,main_type,01,02,03,04,05,06,07,08,09,10
01,æ­¦å™¨,æ ¼æ–—,ç™½åˆƒ,å™¨æ¢°,æŠ•æ·,å°„å‡»,æ‰«å°„,æ³•æ–,é¢„ç•™1,é¢„ç•™2,é¢„ç•™3
02,æŠ¤ç”²,èº«ä½“,å¤§è¡£,å¤´,æ‰‹è‡‚,è¶³,å¥—è£…,é¢„ç•™1,é¢„ç•™2,é¢„ç•™3,é¢„ç•™4
03,æ¶ˆè€—å“,è¯æ°´,çƒŸ,é…’,å¼¹è¯,é¥²æ–™,é£Ÿç‰©,ç‚¼é‡‘,æ¯’è¯,ç‰¹æ®Š,é¢„ç•™1
04,å·¥å…·,ç…§æ˜,å·¥åŒ ,é‡‡é›†,ç»´ä¿®,é¢„ç•™1,é¢„ç•™2,é¢„ç•™3,é¢„ç•™4,é¢„ç•™5,é¢„ç•™6
05,å®¹å™¨,èƒŒåŒ…,ç®±å­,è¢‹å­,é¢„ç•™1,é¢„ç•™2,é¢„ç•™3,é¢„ç•™4,é¢„ç•™5,é¢„ç•™6,é¢„ç•™7
06,é¥°å“,é¡¹é“¾,æˆ’æŒ‡,æŠ¤ç¬¦,è€³ç¯,é¢„ç•™1,é¢„ç•™2,é¢„ç•™3,é¢„ç•™4,é¢„ç•™5,é¢„ç•™6
07,åŸæ–™,é‡‘å±,æœ¨æ,å¸ƒæ–™,çš®é©,é¢„ç•™1,é¢„ç•™2,é¢„ç•™3,é¢„ç•™4,é¢„ç•™5,é¢„ç•™6
08,å®çŸ³,å…ƒç´ ,ç¥åœ£,ç”Ÿå‘½,é¢„ç•™1,é¢„ç•™2,é¢„ç•™3,é¢„ç•™4,é¢„ç•™5,é¢„ç•™6,é¢„ç•™7
09,ç‰¹æ®Š,ä»»åŠ¡,æ”¶è—,é¢„ç•™1,é¢„ç•™2,é¢„ç•™3,é¢„ç•™4,é¢„ç•™5,é¢„ç•™6,é¢„ç•™7`;
            }
            
            // å†…ç½®é¢„è®¾è£…å¤‡åŒ… - æ–°æ ¼å¼
            getBuiltinPresets() {
                return `20240520
name,01,02,03,04,05,06
æˆ˜å£«,'é“å‰‘,1','çš®é©å¤§è¡£,1','å®‰å…¨å¸½,1','é“ç›¾,1','æ²»ç–—è¯æ°´,2',''
æ³•å¸ˆ,'è“ç‰æ³•æ–,1','æ—…äººé£è¡£,1','å¸ƒåŒ…,1','æ²»ç–—è¯æ°´,3','',''
æ¸¸è¡è€…,'æœ¨å¼“,1','æ—…äººé£è¡£,1','æ²»ç–—è¯æ°´,3','','',''`;
            }
        }

        // ================================
        // æ¨¡å—åŒ–è®¾è®¡ï¼šç­›é€‰ç®¡ç†å™¨
        // ================================
        class FilterManager {
            constructor(itemManager) {
                this.itemManager = itemManager;
                this.selectedTags = new Set();
                this.selectedRarity = new Set();
                this.selectedMaterial = new Set();
                this.selectedSkill = new Set();
                this.filterRule = 'AND';
                
                // é˜²æŠ–å®šæ—¶å™¨
                this.debounceTimer = null;
            }
            
            // åˆå§‹åŒ–ç­›é€‰ç•Œé¢
            initializeFilterUI() {
                this.renderTagFilter();
                this.initializeEventListeners();
            }
            
            // æ¸²æŸ“æ ‡ç­¾ç­›é€‰å™¨
            renderTagFilter() {
                const container = document.getElementById('tag-filter-container');
                container.innerHTML = '';
                
                // åˆ›å»ºæ ‡ç­¾åˆ†ç±»
                const categories = [
                    {
                        title: 'æ ‡ç­¾ç­›é€‰',
                        key: 'tags',
                        values: this.itemManager.getAllTags(),
                        selected: this.selectedTags
                    },
                    {
                        title: 'ç¨€æœ‰åº¦',
                        key: 'rarity',
                        values: this.itemManager.getAllRarity(),
                        selected: this.selectedRarity
                    },
                    {
                        title: 'æè´¨',
                        key: 'material', 
                        values: this.itemManager.getAllMaterial(),
                        selected: this.selectedMaterial
                    },
                    {
                        title: 'æŠ€èƒ½éœ€æ±‚',
                        key: 'skill',
                        values: this.itemManager.getAllSkill(),
                        selected: this.selectedSkill
                    }
                ];
                
                // æ¸²æŸ“æ¯ä¸ªåˆ†ç±»
                categories.forEach(category => {
                    if (category.values.size === 0) return;
                    
                    const categoryElement = document.createElement('div');
                    categoryElement.className = 'filter-category';
                    
                    const titleElement = document.createElement('div');
                    titleElement.className = 'filter-category-title';
                    titleElement.textContent = category.title;
                    
                    const contentElement = document.createElement('div');
                    contentElement.className = 'filter-category-content tag-filter';
                    
                    // æ·»åŠ æ ‡ç­¾é€‰é¡¹
                    Array.from(category.values).sort().forEach(value => {
                        if (!value || value === '') return;
                        
                        const tagElement = document.createElement('div');
                        tagElement.className = 'tag-option';
                        tagElement.textContent = value;
                        tagElement.dataset.category = category.key;
                        tagElement.dataset.value = value;
                        
                        if (category.selected.has(value)) {
                            tagElement.classList.add('selected');
                        }
                        
                        // æ£€æŸ¥æ ‡ç­¾æ˜¯å¦åœ¨å½“å‰ç­›é€‰æ¡ä»¶ä¸‹å¯ç”¨
                        if (!this.isTagAvailable(category.key, value)) {
                            tagElement.classList.add('disabled');
                        }
                        
                        tagElement.addEventListener('click', () => {
                            if (tagElement.classList.contains('disabled')) return;
                            
                            this.toggleTag(category.key, value);
                            this.applyFilterDebounced();
                        });
                        
                        contentElement.appendChild(tagElement);
                    });
                    
                    categoryElement.appendChild(titleElement);
                    categoryElement.appendChild(contentElement);
                    container.appendChild(categoryElement);
                });
                
                // æ·»åŠ ç­›é€‰è§„åˆ™é€‰æ‹©å™¨
                const ruleContainer = document.createElement('div');
                ruleContainer.className = 'filter-rule-selector';
                ruleContainer.innerHTML = `
                    <label>
                        <input type="radio" name="filter-rule" value="OR" ${this.filterRule === 'OR' ? 'checked' : ''}> ä»»ä¸€æ ‡ç­¾ (OR)
                    </label>
                    <label>
                        <input type="radio" name="filter-rule" value="AND" ${this.filterRule === 'AND' ? 'checked' : ''}> æ‰€æœ‰æ ‡ç­¾ (AND)
                    </label>
                `;
                container.appendChild(ruleContainer);
                
                // æ·»åŠ ç­›é€‰è§„åˆ™äº‹ä»¶ç›‘å¬
                document.querySelectorAll('input[name="filter-rule"]').forEach(radio => {
                    radio.addEventListener('change', (e) => {
                        this.filterRule = e.target.value;
                        this.applyFilterDebounced();
                    });
                });
            }
            
            // æ£€æŸ¥æ ‡ç­¾æ˜¯å¦åœ¨å½“å‰ç­›é€‰æ¡ä»¶ä¸‹å¯ç”¨
            isTagAvailable(category, value) {
                // è·å–å½“å‰ç­›é€‰æ¡ä»¶ä¸‹çš„ç‰©å“
                const currentItems = this.itemManager.getFilteredItems(
                    this.selectedTags,
                    this.selectedRarity,
                    this.selectedMaterial, 
                    this.selectedSkill,
                    this.filterRule
                );
                
                // æ£€æŸ¥æ˜¯å¦æœ‰ç‰©å“åŒ…å«æ­¤æ ‡ç­¾
                return currentItems.some(item => {
                    switch(category) {
                        case 'tags': return item.tags.includes(value);
                        case 'rarity': return item.rarity === value;
                        case 'material': return item.material === value;
                        case 'skill': return item.skill === value;
                        default: return false;
                    }
                });
            }
            
            // åˆ‡æ¢æ ‡ç­¾é€‰æ‹©çŠ¶æ€
            toggleTag(category, value) {
                let targetSet;
                
                switch(category) {
                    case 'tags': targetSet = this.selectedTags; break;
                    case 'rarity': targetSet = this.selectedRarity; break;
                    case 'material': targetSet = this.selectedMaterial; break;
                    case 'skill': targetSet = this.selectedSkill; break;
                    default: return;
                }
                
                if (targetSet.has(value)) {
                    targetSet.delete(value);
                } else {
                    targetSet.add(value);
                }
            }
            
            // è·å–å½“å‰ç­›é€‰æ¡ä»¶
            getCurrentFilters() {
                return {
                    tags: this.selectedTags,
                    rarity: this.selectedRarity,
                    material: this.selectedMaterial,
                    skill: this.selectedSkill,
                    rule: this.filterRule
                };
            }
            
            // æ¸…é™¤æ‰€æœ‰ç­›é€‰
            clearAllFilters() {
                this.selectedTags.clear();
                this.selectedRarity.clear();
                this.selectedMaterial.clear();
                this.selectedSkill.clear();
                this.filterRule = 'AND';
                
                // æ›´æ–°UI
                this.renderTagFilter();
            }
            
            // åˆå§‹åŒ–äº‹ä»¶ç›‘å¬å™¨
            initializeEventListeners() {
                // åç§°ç­›é€‰
                document.getElementById('name-filter').addEventListener('input', () => {
                    this.applyFilterDebounced();
                });
                
                // ä»·æ ¼ç­›é€‰
                document.getElementById('min-cost').addEventListener('input', () => {
                    this.applyFilterDebounced();
                });
                
                document.getElementById('max-cost').addEventListener('input', () => {
                    this.applyFilterDebounced();
                });
                
                // æ’åºé€‰æ‹©
                document.getElementById('sort-by').addEventListener('change', (e) => {
                    this.itemManager.setSortBy(e.target.value);
                    this.applyFilterDebounced();
                });
                
                // ä¸»ç±»å‹é€‰æ‹©å˜åŒ–
                document.getElementById('main-type-filter').addEventListener('change', (e) => {
                    this.itemManager.updateSubTypeFilter(e.target.value);
                    this.applyFilterDebounced();
                });
                
                // å­ç±»å‹é€‰æ‹©å˜åŒ–
                document.getElementById('sub-type-filter').addEventListener('change', () => {
                    this.applyFilterDebounced();
                });
            }
            
            // é˜²æŠ–åº”ç”¨ç­›é€‰
            applyFilterDebounced() {
                if (this.debounceTimer) {
                    clearTimeout(this.debounceTimer);
                }
                
                this.debounceTimer = setTimeout(() => {
                    this.applyFilter();
                }, 300);
            }
            
            // åº”ç”¨ç­›é€‰
            applyFilter() {
                // è·å–åç§°å’Œä»·æ ¼ç­›é€‰æ¡ä»¶
                const nameFilter = document.getElementById('name-filter').value.toLowerCase();
                const minCost = document.getElementById('min-cost').value ? parseFloat(document.getElementById('min-cost').value) : null;
                const maxCost = document.getElementById('max-cost').value ? parseFloat(document.getElementById('max-cost').value) : null;
                const mainTypeFilter = document.getElementById('main-type-filter').value;
                const subTypeFilter = document.getElementById('sub-type-filter').value;
                
                // æ›´æ–°æ´»åŠ¨ç­›é€‰æ˜¾ç¤º
                this.updateActiveFilters(mainTypeFilter, subTypeFilter, nameFilter, minCost, maxCost);
                
                // åº”ç”¨ç­›é€‰
                this.itemManager.applyFilter(
                    this.selectedTags,
                    this.selectedRarity,
                    this.selectedMaterial,
                    this.selectedSkill,
                    this.filterRule,
                    nameFilter,
                    minCost,
                    maxCost,
                    mainTypeFilter,
                    subTypeFilter
                );
                
                // æ›´æ–°æ ‡ç­¾å¯ç”¨æ€§
                this.renderTagFilter();
            }
            
            // æ›´æ–°æ´»åŠ¨ç­›é€‰æ˜¾ç¤º
            updateActiveFilters(mainTypeFilter, subTypeFilter, nameFilter, minCost, maxCost) {
                const activeFiltersContainer = document.getElementById('active-filters');
                const activeFilterTags = document.getElementById('active-filter-tags');
                
                activeFilterTags.innerHTML = '';
                let hasActiveFilters = false;
                
                // ç±»å‹ç­›é€‰
                if (mainTypeFilter) {
                    const mainTypeMapping = this.itemManager.getTypeMapping().get(mainTypeFilter);
                    if (mainTypeMapping) {
                        const tag = document.createElement('span');
                        tag.className = 'active-filter-tag';
                        tag.innerHTML = `ä¸»ç±»å‹: ${mainTypeMapping.mainType} <span class="remove" data-type="main-type">Ã—</span>`;
                        activeFilterTags.appendChild(tag);
                        hasActiveFilters = true;
                    }
                }
                
                if (subTypeFilter) {
                    const mainTypeFilterValue = document.getElementById('main-type-filter').value;
                    if (mainTypeFilterValue) {
                        const mainTypeMapping = this.itemManager.getTypeMapping().get(mainTypeFilterValue);
                        if (mainTypeMapping) {
                            const subTypeName = mainTypeMapping.subTypes.get(subTypeFilter) || 'æœªçŸ¥';
                            const tag = document.createElement('span');
                            tag.className = 'active-filter-tag';
                            tag.innerHTML = `å­ç±»å‹: ${subTypeName} <span class="remove" data-type="sub-type">Ã—</span>`;
                            activeFilterTags.appendChild(tag);
                            hasActiveFilters = true;
                        }
                    }
                }
                
                // åç§°ç­›é€‰
                if (nameFilter) {
                    const tag = document.createElement('span');
                    tag.className = 'active-filter-tag';
                    tag.innerHTML = `åç§°: ${nameFilter} <span class="remove" data-type="name">Ã—</span>`;
                    activeFilterTags.appendChild(tag);
                    hasActiveFilters = true;
                }
                
                // ä»·æ ¼ç­›é€‰
                if (minCost !== null || maxCost !== null) {
                    let priceText = 'ä»·æ ¼: ';
                    if (minCost !== null && maxCost !== null) {
                        priceText += `${minCost} - ${maxCost}`;
                    } else if (minCost !== null) {
                        priceText += `â‰¥ ${minCost}`;
                    } else {
                        priceText += `â‰¤ ${maxCost}`;
                    }
                    
                    const tag = document.createElement('span');
                    tag.className = 'active-filter-tag';
                    tag.innerHTML = `${priceText} <span class="remove" data-type="price">Ã—</span>`;
                    activeFilterTags.appendChild(tag);
                    hasActiveFilters = true;
                }
                
                // æ ‡ç­¾ç­›é€‰
                const allSelectedTags = [
                    ...Array.from(this.selectedTags).map(t => `æ ‡ç­¾: ${t}`),
                    ...Array.from(this.selectedRarity).map(t => `ç¨€æœ‰åº¦: ${t}`),
                    ...Array.from(this.selectedMaterial).map(t => `æè´¨: ${t}`),
                    ...Array.from(this.selectedSkill).map(t => `æŠ€èƒ½: ${t}`)
                ];
                
                if (allSelectedTags.length > 0) {
                    allSelectedTags.forEach(tagText => {
                        const tag = document.createElement('span');
                        tag.className = 'active-filter-tag';
                        tag.innerHTML = `${tagText} <span class="remove" data-type="tags">Ã—</span>`;
                        activeFilterTags.appendChild(tag);
                    });
                    hasActiveFilters = true;
                }
                
                // æ˜¾ç¤ºæˆ–éšè—æ´»åŠ¨ç­›é€‰åŒºåŸŸ
                if (hasActiveFilters) {
                    activeFiltersContainer.style.display = 'block';
                    
                    // æ·»åŠ ç§»é™¤ç­›é€‰çš„äº‹ä»¶ç›‘å¬
                    document.querySelectorAll('.active-filter-tag .remove').forEach(removeBtn => {
                        removeBtn.addEventListener('click', (e) => {
                            e.stopPropagation();
                            const filterType = e.target.getAttribute('data-type');
                            this.removeFilter(filterType);
                        });
                    });
                } else {
                    activeFiltersContainer.style.display = 'none';
                }
            }
            
            // ç§»é™¤ç‰¹å®šç­›é€‰
            removeFilter(filterType) {
                switch(filterType) {
                    case 'main-type':
                        document.getElementById('main-type-filter').value = '';
                        this.itemManager.updateSubTypeFilter('');
                        break;
                    case 'sub-type':
                        document.getElementById('sub-type-filter').value = '';
                        break;
                    case 'name':
                        document.getElementById('name-filter').value = '';
                        break;
                    case 'price':
                        document.getElementById('min-cost').value = '';
                        document.getElementById('max-cost').value = '';
                        break;
                    case 'tags':
                        this.clearAllFilters();
                        break;
                }
                this.applyFilterDebounced();
            }
        }

        // ================================
        // æ¨¡å—åŒ–è®¾è®¡ï¼šç‰©å“ç®¡ç†å™¨
        // ================================
        class ItemManager {
            constructor(dataManager) {
                this.dataManager = dataManager;
                this.items = [];
                this.typeMapping = new Map();
                this.presets = new Map();
                this.filteredItems = [];
                
                // åˆ†é¡µç›¸å…³
                this.currentPage = 1;
                this.itemsPerPage = 20;
                
                // æ’åºç›¸å…³
                this.sortBy = 'name-asc';
            }
            
            // åŠ è½½æ‰€æœ‰æ•°æ®
            async loadAllData() {
                try {
                    const [items, mapping, presets] = await Promise.all([
                        this.dataManager.loadItems().catch(e => {
                            console.error('åŠ è½½ç‰©å“æ•°æ®å¤±è´¥:', e);
                            return [];
                        }),
                        this.dataManager.loadTypeMapping().catch(e => {
                            console.error('åŠ è½½ç±»å‹æ˜ å°„å¤±è´¥:', e);
                            return new Map();
                        }),
                        this.dataManager.loadPresets().catch(e => {
                            console.error('åŠ è½½é¢„è®¾å¤±è´¥:', e);
                            return new Map();
                        })
                    ]);
                    
                    this.items = items || [];
                    this.typeMapping = mapping || new Map();
                    this.presets = presets || new Map();
                    
                    // åº”ç”¨ç±»å‹æ˜ å°„åˆ°ç‰©å“
                    this.applyTypeMapping();
                    
                    // åˆå§‹åŒ–ä¸»ç±»å‹ç­›é€‰å™¨
                    this.initializeMainTypeFilter();
                    
                    return true;
                } catch (error) {
                    console.error('åŠ è½½æ‰€æœ‰æ•°æ®å¤±è´¥:', error);
                    return false;
                }
            }
            
            // åº”ç”¨ç±»å‹æ˜ å°„åˆ°ç‰©å“
            applyTypeMapping() {
                this.items.forEach(item => {
                    const typeInfo = this.resolveTypeInfo(item.id);
                    if (typeInfo) {
                        item.mainType = typeInfo.mainType;
                        item.subType = typeInfo.subType;
                        item.type = `${typeInfo.mainType} - ${typeInfo.subType}`;
                        item.mainTypeCode = typeInfo.mainTypeCode;
                        item.subTypeCode = typeInfo.subTypeCode;
                    } else {
                        // å¦‚æœæ— æ³•è§£æç±»å‹ï¼Œä½¿ç”¨é»˜è®¤å€¼
                        item.mainType = 'æœªçŸ¥';
                        item.subType = 'æœªçŸ¥';
                        item.type = 'æœªçŸ¥';
                        item.mainTypeCode = '00';
                        item.subTypeCode = '00';
                    }
                });
            }
            
            // è§£æç±»å‹ä¿¡æ¯
            resolveTypeInfo(itemId) {
                try {
                    const idStr = itemId.toString().padStart(7, '0');
                    const typeCode = idStr.substring(0, 2);
                    const subTypeCode = idStr.substring(2, 4);
                    
                    const mapping = this.typeMapping.get(typeCode);
                    if (!mapping) return null;
                    
                    // ä»Mapä¸­è·å–å­ç±»å‹åç§°
                    const subTypeName = mapping.subTypes.get(subTypeCode) || 'æœªçŸ¥';
                    
                    return {
                        mainType: mapping.mainType,
                        subType: subTypeName,
                        mainTypeCode: typeCode,
                        subTypeCode: subTypeCode
                    };
                } catch (error) {
                    console.warn(`è§£æç‰©å“ç±»å‹ä¿¡æ¯å¤±è´¥: ${itemId}`, error);
                    return null;
                }
            }
            
            // è·å–ç±»å‹æ˜ å°„
            getTypeMapping() {
                return this.typeMapping;
            }
            
            // åˆå§‹åŒ–ä¸»ç±»å‹ç­›é€‰å™¨
            initializeMainTypeFilter() {
                const mainTypeSelector = document.getElementById('main-type-filter');
                mainTypeSelector.innerHTML = '<option value="">æ‰€æœ‰ä¸»ç±»å‹</option>';
                
                // æ·»åŠ æ‰€æœ‰ä¸»ç±»å‹é€‰é¡¹
                this.typeMapping.forEach((mapping, typeCode) => {
                    const option = document.createElement('option');
                    option.value = typeCode;
                    option.textContent = mapping.mainType;
                    mainTypeSelector.appendChild(option);
                });
            }
            
            // æ›´æ–°å­ç±»å‹ç­›é€‰å™¨
            updateSubTypeFilter(mainTypeCode) {
                const subTypeSelector = document.getElementById('sub-type-filter');
                
                // æ¸…ç©ºç°æœ‰é€‰é¡¹
                subTypeSelector.innerHTML = '<option value="">æ‰€æœ‰å­ç±»å‹</option>';
                
                if (mainTypeCode) {
                    const mapping = this.typeMapping.get(mainTypeCode);
                    if (mapping && mapping.subTypes) {
                        // æ·»åŠ å­ç±»å‹é€‰é¡¹
                        mapping.subTypes.forEach((subTypeName, subTypeCode) => {
                            const option = document.createElement('option');
                            option.value = subTypeCode;
                            option.textContent = subTypeName;
                            subTypeSelector.appendChild(option);
                        });
                    }
                    subTypeSelector.style.display = 'block';
                } else {
                    subTypeSelector.style.display = 'none';
                }
            }
            
            // è·å–æ‰€æœ‰æ ‡ç­¾
            getAllTags() {
                const allTags = new Set();
                this.items.forEach(item => {
                    if (item.tags && Array.isArray(item.tags)) {
                        item.tags.forEach(tag => {
                            if (tag && tag !== '') allTags.add(tag);
                        });
                    }
                });
                return allTags;
            }
            
            // è·å–æ‰€æœ‰ç¨€æœ‰åº¦
            getAllRarity() {
                const allRarity = new Set();
                this.items.forEach(item => {
                    if (item.rarity && item.rarity !== '') {
                        allRarity.add(item.rarity);
                    }
                });
                return allRarity;
            }
            
            // è·å–æ‰€æœ‰æè´¨
            getAllMaterial() {
                const allMaterial = new Set();
                this.items.forEach(item => {
                    if (item.material && item.material !== '') {
                        allMaterial.add(item.material);
                    }
                });
                return allMaterial;
            }
            
            // è·å–æ‰€æœ‰æŠ€èƒ½éœ€æ±‚
            getAllSkill() {
                const allSkill = new Set();
                this.items.forEach(item => {
                    if (item.skill && item.skill !== '' && item.skill !== 'æ— ') {
                        allSkill.add(item.skill);
                    }
                });
                return allSkill;
            }
            
            // è®¾ç½®æ’åºæ–¹å¼
            setSortBy(sortBy) {
                this.sortBy = sortBy;
            }
            
            // åº”ç”¨ç­›é€‰
            applyFilter(selectedTags, selectedRarity, selectedMaterial, selectedSkill, filterRule, 
                       nameFilter, minCost, maxCost, mainTypeFilter, subTypeFilter) {
                // ç­›é€‰ç‰©å“
                this.filteredItems = this.items.filter(item => {
                    // ä¸»ç±»å‹ç­›é€‰
                    if (mainTypeFilter && item.mainTypeCode !== mainTypeFilter) {
                        return false;
                    }
                    
                    // å­ç±»å‹ç­›é€‰
                    if (subTypeFilter && item.subTypeCode !== subTypeFilter) {
                        return false;
                    }
                    
                    // åç§°ç­›é€‰
                    if (nameFilter && !item.name.toLowerCase().includes(nameFilter)) {
                        return false;
                    }
                    
                    // ä»·æ ¼ç­›é€‰
                    if (minCost !== null && item.cost < minCost) return false;
                    if (maxCost !== null && item.cost > maxCost) return false;
                    
                    // æ ‡ç­¾ç­›é€‰ï¼ˆæ”¯æŒAND/ORï¼‰
                    if (selectedTags.size > 0) {
                        if (filterRule === 'OR') {
                            // ORé€»è¾‘ï¼šåŒ…å«ä»»ä¸€é€‰ä¸­æ ‡ç­¾
                            const hasSelectedTag = Array.from(selectedTags).some(tag => 
                                item.tags.includes(tag)
                            );
                            if (!hasSelectedTag) return false;
                        } else {
                            // ANDé€»è¾‘ï¼šåŒ…å«æ‰€æœ‰é€‰ä¸­æ ‡ç­¾
                            const hasAllTags = Array.from(selectedTags).every(tag => 
                                item.tags.includes(tag)
                            );
                            if (!hasAllTags) return false;
                        }
                    }
                    
                    // ç¨€æœ‰åº¦ç­›é€‰
                    if (selectedRarity.size > 0 && !selectedRarity.has(item.rarity)) {
                        return false;
                    }
                    
                    // æè´¨ç­›é€‰
                    if (selectedMaterial.size > 0 && !selectedMaterial.has(item.material)) {
                        return false;
                    }
                    
                    // æŠ€èƒ½éœ€æ±‚ç­›é€‰
                    if (selectedSkill.size > 0 && !selectedSkill.has(item.skill)) {
                        return false;
                    }
                    
                    return true;
                });
                
                // åº”ç”¨æ’åº
                this.applySorting();
                
                // é‡ç½®åˆ°ç¬¬ä¸€é¡µ
                this.currentPage = 1;
                
                // æ¸²æŸ“ç­›é€‰ç»“æœ
                this.renderFilterResults();
            }
            
            // è·å–ç­›é€‰åçš„ç‰©å“ï¼ˆç”¨äºæ ‡ç­¾å¯ç”¨æ€§æ£€æŸ¥ï¼‰
            getFilteredItems(selectedTags, selectedRarity, selectedMaterial, selectedSkill, filterRule) {
                return this.items.filter(item => {
                    // æ ‡ç­¾ç­›é€‰ï¼ˆæ”¯æŒAND/ORï¼‰
                    if (selectedTags.size > 0) {
                        if (filterRule === 'OR') {
                            // ORé€»è¾‘ï¼šåŒ…å«ä»»ä¸€é€‰ä¸­æ ‡ç­¾
                            const hasSelectedTag = Array.from(selectedTags).some(tag => 
                                item.tags.includes(tag)
                            );
                            if (!hasSelectedTag) return false;
                        } else {
                            // ANDé€»è¾‘ï¼šåŒ…å«æ‰€æœ‰é€‰ä¸­æ ‡ç­¾
                            const hasAllTags = Array.from(selectedTags).every(tag => 
                                item.tags.includes(tag)
                            );
                            if (!hasAllTags) return false;
                        }
                    }
                    
                    // ç¨€æœ‰åº¦ç­›é€‰
                    if (selectedRarity.size > 0 && !selectedRarity.has(item.rarity)) {
                        return false;
                    }
                    
                    // æè´¨ç­›é€‰
                    if (selectedMaterial.size > 0 && !selectedMaterial.has(item.material)) {
                        return false;
                    }
                    
                    // æŠ€èƒ½éœ€æ±‚ç­›é€‰
                    if (selectedSkill.size > 0 && !selectedSkill.has(item.skill)) {
                        return false;
                    }
                    
                    return true;
                });
            }
            
            // åº”ç”¨æ’åº
            applySorting() {
                switch(this.sortBy) {
                    case 'name-asc':
                        this.filteredItems.sort((a, b) => a.name.localeCompare(b.name));
                        break;
                    case 'name-desc':
                        this.filteredItems.sort((a, b) => b.name.localeCompare(a.name));
                        break;
                    case 'cost-asc':
                        this.filteredItems.sort((a, b) => a.cost - b.cost);
                        break;
                    case 'cost-desc':
                        this.filteredItems.sort((a, b) => b.cost - a.cost);
                        break;
                    case 'weight-asc':
                        this.filteredItems.sort((a, b) => a.weight - b.weight);
                        break;
                    case 'weight-desc':
                        this.filteredItems.sort((a, b) => b.weight - a.weight);
                        break;
                }
            }
            
            // æ¸²æŸ“ç­›é€‰ç»“æœ
            renderFilterResults() {
                const itemList = document.getElementById('item-list');
                const pagination = document.getElementById('pagination');
                
                // æ¸…ç©ºåˆ—è¡¨
                itemList.innerHTML = '';
                
                if (this.filteredItems.length === 0) {
                    itemList.innerHTML = '<div class="empty-state">æ²¡æœ‰æ‰¾åˆ°åŒ¹é…çš„ç‰©å“</div>';
                    pagination.style.display = 'none';
                    return;
                }
                
                // è®¡ç®—åˆ†é¡µ
                const totalPages = Math.ceil(this.filteredItems.length / this.itemsPerPage);
                const startIndex = (this.currentPage - 1) * this.itemsPerPage;
                const endIndex = Math.min(startIndex + this.itemsPerPage, this.filteredItems.length);
                const pageItems = this.filteredItems.slice(startIndex, endIndex);
                
                // æ¸²æŸ“å½“å‰é¡µçš„ç‰©å“
                pageItems.forEach(item => {
                    const itemCard = document.createElement('div');
                    itemCard.className = 'item-card';
                    
                    itemCard.innerHTML = `
                        <div class="item-header">
                            <div>
                                <div class="item-name">${this.escapeHtml(item.name)}</div>
                                <div>
                                    <span class="item-id">ID: ${item.id}</span>
                                    ${item.rarity ? `<span class="tag">${item.rarity}</span>` : ''}
                                    ${item.material ? `<span class="tag">${item.material}</span>` : ''}
                                    ${item.skill && item.skill !== 'æ— ' ? `<span class="tag">${item.skill}</span>` : ''}
                                </div>
                            </div>
                            <button class="btn-success add-to-calculator" data-id="${item.id}">æ·»åŠ åˆ°è®¡ç®—å™¨</button>
                        </div>
                        <div class="item-tags">
                            ${item.tags.map(tag => `<span class="tag">${this.escapeHtml(tag)}</span>`).join('')}
                        </div>
                        <div class="item-description">${this.escapeHtml(item.description)}</div>
                        <div class="item-footer">
                            <div>ä»·æ ¼: ${this.formatCurrency(item.cost)}</div>
                            <div>é‡é‡: ${item.weight}</div>
                            <div>ç±»å‹: ${item.type}</div>
                        </div>
                    `;
                    
                    itemList.appendChild(itemCard);
                });
                
                // æ›´æ–°åˆ†é¡µä¿¡æ¯
                document.getElementById('page-info').textContent = 
                    `ç¬¬ ${this.currentPage} é¡µï¼Œå…± ${totalPages} é¡µ (${this.filteredItems.length} ä¸ªç‰©å“)`;
                
                // æ˜¾ç¤ºåˆ†é¡µæ§ä»¶
                pagination.style.display = 'flex';
                
                // æ›´æ–°åˆ†é¡µæŒ‰é’®çŠ¶æ€
                document.getElementById('prev-page').disabled = this.currentPage === 1;
                document.getElementById('next-page').disabled = this.currentPage === totalPages;
                
                // æ·»åŠ äº‹ä»¶ç›‘å¬å™¨
                document.querySelectorAll('.add-to-calculator').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const itemId = e.target.dataset.id;
                        this.addToCalculator(itemId);
                    });
                });
            }
            
            // æ·»åŠ åˆ°è®¡ç®—å™¨
            addToCalculator(itemId) {
                // è¿™ä¸ªåŠŸèƒ½éœ€è¦ä¸è®¡ç®—å™¨æ¨¡å—äº¤äº’
                if (window.calculatorModule) {
                    window.calculatorModule.addItem(itemId);
                }
            }
            
            // åº”ç”¨é¢„è®¾è£…å¤‡åŒ…
            applyPreset(presetName) {
                const preset = this.presets.get(presetName);
                if (!preset) {
                    this.showStatus(`é¢„è®¾è£…å¤‡åŒ… ${presetName} ä¸å­˜åœ¨`, 'error');
                    return;
                }
                
                // æ¸…ç©ºå½“å‰è®¡ç®—å™¨
                if (window.calculatorModule) {
                    window.calculatorModule.clearCalculator();
                }
                
                // æ ¹æ®é¢„è®¾æ·»åŠ ç‰©å“
                const unresolvedItems = [];
                
                preset.items.forEach(presetItem => {
                    const item = this.items.find(i => i.name === presetItem.name);
                    if (item) {
                        for (let i = 0; i < presetItem.quantity; i++) {
                            this.addToCalculator(item.id);
                        }
                    } else {
                        unresolvedItems.push(presetItem.name);
                    }
                });
                
                if (unresolvedItems.length > 0) {
                    this.showStatus(`åº”ç”¨ ${preset.name} å®Œæˆï¼Œä½† ${unresolvedItems.length} ä¸ªç‰©å“æœªæ‰¾åˆ°`, 'warning');
                } else {
                    this.showStatus(`å·²åº”ç”¨ ${preset.name}`, 'success');
                }
            }
            
            // ä¸Šä¸€é¡µ
            prevPage() {
                if (this.currentPage > 1) {
                    this.currentPage--;
                    this.renderFilterResults();
                }
            }
            
            // ä¸‹ä¸€é¡µ
            nextPage() {
                const totalPages = Math.ceil(this.filteredItems.length / this.itemsPerPage);
                if (this.currentPage < totalPages) {
                    this.currentPage++;
                    this.renderFilterResults();
                }
            }
            
            // è´§å¸æ ¼å¼åŒ– - æ–°ç‰ˆï¼šæ˜¾ç¤ºä¸º"é‡‘å¸ é“¶å¸ é“œå¸"
            formatCurrency(copper) {
                // æ ¹æ®è§„åˆ™ä¹¦ï¼š1é‡‘å¸ = 100é“¶å¸ = 10000é“œå¸
                const gold = Math.floor(copper / 10000);
                const silver = Math.floor((copper % 10000) / 100);
                const copperRemainder = copper % 100;
                
                let result = [];
                if (gold > 0) result.push(`${gold}é‡‘å¸`);
                if (silver > 0) result.push(`${silver}é“¶å¸`);
                if (copperRemainder > 0 || result.length === 0) result.push(`${copperRemainder}é“œå¸`);
                
                return result.join(' ');
            }
            
            // HTMLè½¬ä¹‰å‡½æ•°
            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }
            
            // æ˜¾ç¤ºçŠ¶æ€æ¶ˆæ¯
            showStatus(message, type) {
                const statusElement = document.getElementById('status-message');
                statusElement.textContent = message;
                statusElement.className = 'status-message';
                
                if (type === 'success') {
                    statusElement.classList.add('status-success');
                } else if (type === 'error') {
                    statusElement.classList.add('status-error');
                } else if (type === 'warning') {
                    statusElement.classList.add('status-warning');
                }
                
                // 3ç§’åè‡ªåŠ¨æ¸…é™¤æˆåŠŸæ¶ˆæ¯
                if (type === 'success') {
                    setTimeout(() => {
                        statusElement.textContent = '';
                        statusElement.className = 'status-message';
                    }, 3000);
                }
            }
        }

        // ================================
        // æ¨¡å—åŒ–è®¾è®¡ï¼šè®¡ç®—å™¨æ¨¡å—
        // ================================
        class CalculatorModule {
            constructor(itemManager) {
                this.itemManager = itemManager;
                this.calculatorItems = this.loadCalculatorItems();
                
                // è§’è‰²å±æ€§
                this.characterStrength = 5;
                this.characterEndurance = 5;
            }
            
            // ä»localStorageåŠ è½½è®¡ç®—å™¨ç‰©å“
            loadCalculatorItems() {
                try {
                    const stored = localStorage.getItem('echo-calculator-items');
                    return stored ? JSON.parse(stored) : [];
                } catch (error) {
                    console.warn('åŠ è½½è®¡ç®—å™¨ç‰©å“å¤±è´¥ï¼Œä½¿ç”¨ç©ºæ•°ç»„:', error);
                    return [];
                }
            }
            
            // ä¿å­˜è®¡ç®—å™¨ç‰©å“åˆ°localStorage
            saveCalculatorItems() {
                try {
                    localStorage.setItem('echo-calculator-items', JSON.stringify(this.calculatorItems));
                } catch (error) {
                    console.warn('ä¿å­˜è®¡ç®—å™¨ç‰©å“å¤±è´¥:', error);
                }
            }
            
            // æ·»åŠ ç‰©å“åˆ°è®¡ç®—å™¨
            addItem(itemId) {
                const item = this.itemManager.items.find(i => i.id == itemId);
                if (!item) {
                    console.warn(`æœªæ‰¾åˆ°ç‰©å“: ${itemId}`);
                    return;
                }
                
                // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨
                const existingItem = this.calculatorItems.find(i => i.id == itemId);
                
                if (existingItem) {
                    existingItem.quantity += 1;
                } else {
                    this.calculatorItems.push({
                        ...item,
                        quantity: 1
                    });
                }
                
                this.saveCalculatorItems();
                this.renderCalculator();
                
                // æ˜¾ç¤ºçŠ¶æ€æ¶ˆæ¯
                this.showStatus(`å·²æ·»åŠ  ${item.name} åˆ°è®¡ç®—å™¨`, 'success');
            }
            
            // ä»è®¡ç®—å™¨ç§»é™¤ç‰©å“
            removeFromCalculator(itemId) {
                this.calculatorItems = this.calculatorItems.filter(item => item.id != itemId);
                this.saveCalculatorItems();
                this.renderCalculator();
            }
            
            // æ›´æ–°è®¡ç®—å™¨ç‰©å“æ•°é‡
            updateQuantity(itemId, newQuantity) {
                const item = this.calculatorItems.find(i => i.id == itemId);
                if (!item) return;
                
                // ç¡®ä¿æ•°é‡æ˜¯æ­£æ•´æ•°
                newQuantity = parseInt(newQuantity);
                if (isNaN(newQuantity) || newQuantity < 0) {
                    newQuantity = 0;
                }
                
                if (newQuantity === 0) {
                    this.removeFromCalculator(itemId);
                } else {
                    item.quantity = newQuantity;
                    this.saveCalculatorItems();
                    this.renderCalculator();
                }
            }
            
            // æ¸²æŸ“è®¡ç®—å™¨
            renderCalculator() {
                const calculatorElement = document.getElementById('calculator-items');
                const totalCostElement = document.getElementById('total-cost');
                const totalWeightElement = document.getElementById('total-weight');
                const carryStatusElement = document.getElementById('carry-status');
                const weightStatusElement = document.getElementById('weight-status');
                
                // æ¸…ç©ºè®¡ç®—å™¨
                calculatorElement.innerHTML = '';
                
                if (this.calculatorItems.length === 0) {
                    calculatorElement.innerHTML = '<div class="empty-state">è®¡ç®—å™¨ä¸ºç©ºï¼Œè¯·ä»ç­›é€‰ç»“æœä¸­æ·»åŠ ç‰©å“</div>';
                    totalCostElement.textContent = '';
                    totalWeightElement.textContent = '0';
                    carryStatusElement.textContent = 'è½»å¿«';
                    weightStatusElement.className = 'weight-status light';
                    return;
                }
                
                // è®¡ç®—æ€»æ¶ˆè€—å’Œæ€»é‡é‡
                let totalCost = 0;
                let totalWeight = 0;
                
                // æ¸²æŸ“è®¡ç®—å™¨ç‰©å“
                this.calculatorItems.forEach(item => {
                    const itemCost = item.cost * item.quantity;
                    const itemWeight = item.weight * item.quantity;
                    totalCost += itemCost;
                    totalWeight += itemWeight;
                    
                    const itemElement = document.createElement('div');
                    itemElement.className = 'calculator-item';
                    
                    itemElement.innerHTML = `
                        <div class="calculator-item-header">
                            <div class="calculator-item-name">${this.escapeHtml(item.name)}</div>
                            <div class="calculator-item-tags">
                                ${item.tags.map(tag => `<span class="calculator-tag">${this.escapeHtml(tag)}</span>`).join('')}
                            </div>
                        </div>
                        <div class="calculator-item-details">
                            <div class="calculator-item-description">${this.escapeHtml(item.description)}</div>
                            <div class="calculator-item-controls">
                                <input type="number" class="quantity-input" value="${item.quantity}" min="0" data-id="${item.id}">
                                <span class="calculator-item-cost">${this.formatCurrency(itemCost)}</span>
                                <button class="btn-danger remove-btn" data-id="${item.id}">åˆ é™¤</button>
                            </div>
                        </div>
                    `;
                    
                    calculatorElement.appendChild(itemElement);
                });
                
                // æ›´æ–°æ€»æ¶ˆè€—å’Œæ€»é‡é‡
                totalCostElement.innerHTML = `<span class="currency-display">æ€»ä»·æ ¼: ${this.formatCurrency(totalCost)}</span>`;
                totalWeightElement.textContent = totalWeight;
                
                // è®¡ç®—è´Ÿé‡çŠ¶æ€
                const carryCapacity = 20 + this.characterStrength + this.characterEndurance * 30;
                const carryPercentage = totalWeight / carryCapacity;
                
                let statusText = '';
                let statusClass = '';
                
                if (carryPercentage <= 0.25) {
                    statusText = 'è½»å¿«';
                    statusClass = 'light';
                } else if (carryPercentage <= 0.5) {
                    statusText = 'æ­£å¸¸';
                    statusClass = 'normal';
                } else if (carryPercentage <= 1) {
                    statusText = 'ç¼“æ…¢';
                    statusClass = 'heavy';
                } else {
                    statusText = 'è¶…é‡';
                    statusClass = 'overloaded';
                }
                
                carryStatusElement.textContent = statusText;
                weightStatusElement.className = `weight-status ${statusClass}`;
                
                // æ·»åŠ äº‹ä»¶ç›‘å¬å™¨
                document.querySelectorAll('.quantity-input').forEach(input => {
                    input.addEventListener('change', (e) => {
                        const itemId = e.target.dataset.id;
                        const newQuantity = parseInt(e.target.value);
                        this.updateQuantity(itemId, newQuantity);
                    });
                    
                    input.addEventListener('blur', (e) => {
                        const itemId = e.target.dataset.id;
                        const newQuantity = parseInt(e.target.value);
                        this.updateQuantity(itemId, newQuantity);
                    });
                });
                
                document.querySelectorAll('.remove-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const itemId = e.target.dataset.id;
                        this.removeFromCalculator(itemId);
                    });
                });
            }
            
            // æ¸…ç©ºè®¡ç®—å™¨
            clearCalculator() {
                this.calculatorItems = [];
                this.saveCalculatorItems();
                this.renderCalculator();
                this.showStatus('è®¡ç®—å™¨å·²æ¸…ç©º', 'success');
            }
            
            // è´§å¸æ ¼å¼åŒ– - æ–°ç‰ˆï¼šæ˜¾ç¤ºä¸º"é‡‘å¸ é“¶å¸ é“œå¸"
            formatCurrency(copper) {
                // æ ¹æ®è§„åˆ™ä¹¦ï¼š1é‡‘å¸ = 100é“¶å¸ = 10000é“œå¸
                const gold = Math.floor(copper / 10000);
                const silver = Math.floor((copper % 10000) / 100);
                const copperRemainder = copper % 100;
                
                let result = [];
                if (gold > 0) result.push(`${gold}é‡‘å¸`);
                if (silver > 0) result.push(`${silver}é“¶å¸`);
                if (copperRemainder > 0 || result.length === 0) result.push(`${copperRemainder}é“œå¸`);
                
                return result.join(' ');
            }
            
            // HTMLè½¬ä¹‰å‡½æ•°
            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }
            
            // æ˜¾ç¤ºçŠ¶æ€æ¶ˆæ¯
            showStatus(message, type) {
                const statusElement = document.getElementById('status-message');
                statusElement.textContent = message;
                statusElement.className = 'status-message';
                
                if (type === 'success') {
                    statusElement.classList.add('status-success');
                } else if (type === 'error') {
                    statusElement.classList.add('status-error');
                } else if (type === 'warning') {
                    statusElement.classList.add('status-warning');
                }
                
                // 3ç§’åè‡ªåŠ¨æ¸…é™¤æˆåŠŸæ¶ˆæ¯
                if (type === 'success') {
                    setTimeout(() => {
                        statusElement.textContent = '';
                        statusElement.className = 'status-message';
                    }, 3000);
                }
            }
        }

        // ================================
        // ä¸»åº”ç”¨ç±»
        // ================================
        class EchoMysteriaCalculator {
            constructor() {
                // åˆå§‹åŒ–å„ä¸ªæ¨¡å—
                this.dataManager = new EchoDataManager();
                this.itemManager = new ItemManager(this.dataManager);
                this.filterManager = new FilterManager(this.itemManager);
                this.calculatorModule = new CalculatorModule(this.itemManager);
                
                // å°†è®¡ç®—å™¨æ¨¡å—æš´éœ²ç»™å…¨å±€ï¼Œä»¥ä¾¿å…¶ä»–æ¨¡å—è°ƒç”¨
                window.calculatorModule = this.calculatorModule;
                
                this.initializeEventListeners();
                this.loadAllData();
                this.calculatorModule.renderCalculator();
            }
            
            // åŠ è½½æ‰€æœ‰å¿…è¦æ•°æ®
            async loadAllData() {
                try {
                    this.showDataStatus('ğŸ”„ æ­£åœ¨åŠ è½½æ•°æ®...', 'loading');
                    
                    const success = await this.itemManager.loadAllData();
                    
                    if (success && this.itemManager.items.length > 0) {
                        this.showDataStatus('âœ… æ•°æ®åŠ è½½å®Œæˆ', 'healthy');
                        this.filterManager.initializeFilterUI();
                        this.updateDataHealthPanel();
                        
                        // æ˜¾ç¤ºæ•°æ®æ¥æºä¿¡æ¯
                        this.showDataSourceInfo();
                        
                        // åˆå§‹åŒ–æ—¶è‡ªåŠ¨åº”ç”¨ç­›é€‰ï¼Œæ˜¾ç¤ºæ‰€æœ‰ç‰©å“
                        this.filterManager.applyFilter();
                    } else {
                        throw new Error('æ•°æ®åŠ è½½å¤±è´¥æˆ–æ²¡æœ‰æ•°æ®');
                    }
                    
                } catch (error) {
                    console.error('æ•°æ®åŠ è½½å¤±è´¥:', error);
                    this.showDataStatus('âŒ æ•°æ®åŠ è½½å¤±è´¥ï¼Œä½¿ç”¨å¤‡ç”¨æ•°æ®', 'error');
                    this.showRecoveryOptions(['æ•°æ®æ–‡ä»¶åŠ è½½å¤±è´¥']);
                    this.updateDataHealthPanel();
                    
                    // å³ä½¿ä½¿ç”¨å¤‡ç”¨æ•°æ®ï¼Œä¹Ÿè¦å°è¯•æ˜¾ç¤ºç­›é€‰ç»“æœ
                    if (this.itemManager.items.length > 0) {
                        this.filterManager.applyFilter();
                    }
                }
            }
            
            // æ˜¾ç¤ºæ•°æ®æ¥æºä¿¡æ¯
            showDataSourceInfo() {
                const statusElement = document.getElementById('data-status');
                const sourceInfo = this.dataManager.getSourceInfo();
                const versionInfo = this.dataManager.getVersionInfo();
                
                let infoHtml = `<div class="data-source-info">`;
                infoHtml += `ç‰©å“: ${sourceInfo.items.source} (${this.itemManager.items.length}ä¸ª)`;
                if (versionInfo.items) infoHtml += ` [v${versionInfo.items}]`;
                infoHtml += ` | ç±»å‹: ${sourceInfo.mapping.source} (${this.itemManager.typeMapping.size}ç±»)`;
                if (versionInfo.mapping) infoHtml += ` [v${versionInfo.mapping}]`;
                infoHtml += ` | é¢„è®¾: ${sourceInfo.presets.source} (${this.itemManager.presets.size}ä¸ª)`;
                if (versionInfo.presets) infoHtml += ` [v${versionInfo.presets}]`;
                infoHtml += `</div>`;
                
                statusElement.insertAdjacentHTML('afterend', infoHtml);
            }
            
            // æ›´æ–°æ•°æ®å¥åº·åº¦é¢æ¿
            updateDataHealthPanel() {
                const healthPanel = document.getElementById('data-health-panel');
                const sourceInfo = this.dataManager.getSourceInfo();
                
                // æ›´æ–°ç‰©å“æ•°æ®çŠ¶æ€
                this.updateHealthIndicator(
                    'items-health-indicator', 
                    'items-health-text', 
                    sourceInfo.items.source, 
                    this.itemManager.items.length
                );
                
                // æ›´æ–°ç±»å‹æ˜ å°„çŠ¶æ€
                this.updateHealthIndicator(
                    'mapping-health-indicator', 
                    'mapping-health-text', 
                    sourceInfo.mapping.source, 
                    this.itemManager.typeMapping.size
                );
                
                // æ›´æ–°é¢„è®¾è£…å¤‡åŒ…çŠ¶æ€
                this.updateHealthIndicator(
                    'presets-health-indicator', 
                    'presets-health-text', 
                    sourceInfo.presets.source, 
                    this.itemManager.presets.size
                );
                
                healthPanel.style.display = 'block';
            }
            
            // æ›´æ–°å¥åº·åº¦æŒ‡ç¤ºå™¨
            updateHealthIndicator(indicatorId, textId, source, count) {
                const indicator = document.getElementById(indicatorId);
                const textElement = document.getElementById(textId);
                
                let healthClass = 'health-healthy';
                let statusText = `${count}ä¸ª`;
                
                if (source === 'builtin') {
                    healthClass = 'health-warning';
                    statusText = `${count}ä¸ª (å†…ç½®)`;
                } else if (source === 'error') {
                    healthClass = 'health-error';
                    statusText = 'åŠ è½½å¤±è´¥';
                } else if (source === 'local') {
                    healthClass = 'health-healthy';
                    statusText = `${count}ä¸ª (æœ¬åœ°)`;
                }
                
                indicator.className = `health-indicator ${healthClass}`;
                textElement.textContent = statusText;
            }
            
            // æ˜¾ç¤ºæ•°æ®çŠ¶æ€
            showDataStatus(message, type) {
                const statusElement = document.getElementById('data-status');
                statusElement.textContent = message;
                statusElement.className = 'status-message';
                
                switch(type) {
                    case 'loading':
                        statusElement.classList.add('status-loading');
                        break;
                    case 'warning':
                        statusElement.classList.add('status-warning');
                        break;
                    case 'error':
                        statusElement.classList.add('status-error');
                        break;
                    case 'healthy':
                        statusElement.classList.add('status-healthy');
                        break;
                }
            }
            
            // æ˜¾ç¤ºæ¢å¤é€‰é¡¹
            showRecoveryOptions(issues) {
                const recoveryContainer = document.getElementById('recovery-container');
                
                const recoveryHtml = `
                    <div class="recovery-panel">
                        <h3>æ•°æ®åŒæ­¥é—®é¢˜</h3>
                        <p>æ£€æµ‹åˆ°ä»¥ä¸‹é—®é¢˜ï¼š</p>
                        <ul>
                            ${issues.map(issue => `<li>${this.escapeHtml(issue)}</li>`).join('')}
                        </ul>
                        <div class="recovery-actions">
                            <button class="btn-success" onclick="echoCalculator.dataManager.forceRefresh()">å¼ºåˆ¶åˆ·æ–°æ•°æ®</button>
                            <button class="btn-warning" onclick="echoCalculator.dataManager.useFallbackData()">ä½¿ç”¨å¤‡ç”¨æ•°æ®</button>
                            <button class="btn-danger" onclick="echoCalculator.ignoreDataIssues()">å¿½ç•¥é—®é¢˜</button>
                        </div>
                    </div>
                `;
                
                recoveryContainer.innerHTML = recoveryHtml;
            }
            
            // å¿½ç•¥æ•°æ®é—®é¢˜
            ignoreDataIssues() {
                document.getElementById('recovery-container').innerHTML = '';
                this.showDataStatus('âš ï¸ ä½¿ç”¨å½“å‰æ•°æ®ç»§ç»­è¿è¡Œ', 'warning');
            }
            
            // åˆå§‹åŒ–äº‹ä»¶ç›‘å¬å™¨
            initializeEventListeners() {
                // è§’è‰²å±æ€§å˜åŒ–
                document.getElementById('character-strength').addEventListener('change', (e) => {
                    this.calculatorModule.characterStrength = parseInt(e.target.value) || 5;
                    this.calculatorModule.renderCalculator();
                });
                
                document.getElementById('character-endurance').addEventListener('change', (e) => {
                    this.calculatorModule.characterEndurance = parseInt(e.target.value) || 5;
                    this.calculatorModule.renderCalculator();
                });
                
                // é¢„è®¾è£…å¤‡åŒ…
                document.querySelectorAll('.preset-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const preset = e.target.dataset.preset;
                        this.itemManager.applyPreset(preset);
                    });
                });
                
                // æ¸…ç©ºè®¡ç®—å™¨
                document.getElementById('clear-calculator').addEventListener('click', () => {
                    this.calculatorModule.clearCalculator();
                });
                
                // æ¸…é™¤ç­›é€‰
                document.getElementById('clear-filter').addEventListener('click', () => {
                    this.filterManager.clearAllFilters();
                    this.filterManager.applyFilter();
                });
                
                // åˆ†é¡µæŒ‰é’®
                document.getElementById('prev-page').addEventListener('click', () => {
                    this.itemManager.prevPage();
                });
                
                document.getElementById('next-page').addEventListener('click', () => {
                    this.itemManager.nextPage();
                });
                
                // æ¯é¡µæ˜¾ç¤ºæ•°é‡å˜åŒ–
                document.getElementById('items-per-page').addEventListener('change', (e) => {
                    this.itemManager.itemsPerPage = parseInt(e.target.value) || 20;
                    this.itemManager.currentPage = 1;
                    this.itemManager.renderFilterResults();
                });
            }
            
            // HTMLè½¬ä¹‰å‡½æ•°
            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }
        }

        // åˆå§‹åŒ–åº”ç”¨
        let echoCalculator;
        document.addEventListener('DOMContentLoaded', () => {
            echoCalculator = new EchoMysteriaCalculator();
        });
    </script>
</body>
</html>